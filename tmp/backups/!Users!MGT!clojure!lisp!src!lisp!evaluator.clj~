(ns lisp.evaluator
  (:require [lisp.env :as env])
  (:refer-clojure :exclude [eval]))

(defmulti eval (fn [x env]
                 (if (sequential? x)
                   :list
                   (class x))))

(defmethod eval java.lang.Long [x env]
  x)

(defmethod eval clojure.lang.Symbol [x env]
  (if (= x 'nil)
    nil
    (env/get env x)))


(defmethod eval :list [x env]
  (cond
   (= (first x) 'quote) (second x)
   (= (first x) 'if) (if (eval (second x) env)
                       (eval (nth x 2) env)
                       (eval (nth x 3) env))
   (= (first x) 'fn) (let [[[& param-names] & body] (rest x)
                           child-env (env/create param-names env)]
                       (fn [& params]
                         (eval (apply list 'do body)
                               child-env)))
   (= (first x) 'set!) (env/set env
                                (nth x 1)
                                (eval (nth x 2) env))
   (= (first x) 'define!) (env/define env (nth x 1) (nth x 2))
   (= (first x) 'do) (map #(eval % env) (rest x))
   :else (let [[fn & args] (map #(eval % env) x)]
           (apply fn args))))
