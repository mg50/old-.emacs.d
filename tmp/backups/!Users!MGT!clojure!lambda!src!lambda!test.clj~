(ns lambda.test
  (:use [lambda.util] [clojure.pprint]))

;(defgrammar lambda-calculus
;  (defrule #"[a-z]\d*" :as variable)
;  (defrule "(" A A ")")
;  (defrule "(L" variable "." A ")" :as lambda)
;  (defrule "(L" variable variable+ "." A ")" :as multilambda)
  
;  (defabbrev A :fallback "(" A ")")
;  (defabbrev multilambda (fn [variable variables subexpr]
;                           (str "(L" variable ".(L" variables "." subexpr "))"))))

"(Lx.x)"
;("(L" variable "." A ")")


(defmacro defgrammar [grammar-name & args]
  `(do
     (def ~grammar-name (atom {:rules [], :transforms []}))
     ~@(map #(list '-> grammar-name %) args)))


(defn defrule- [grammar args]
  (let [part (partition-by keyword? args)
        rule-list (first part)
        rule-name (if (= 3 (count part))
                    (first (nth part 2))
                    nil)
        rule-hash {:rule rule-list, :name rule-name}
        old-rules (:rules @grammar)
        new-rules (conj old-rules rule-hash)]
    (swap! grammar #(assoc % :rules new-rules))))

(defmacro defrule [grammar & args]
  `(defrule- ~grammar (quote ~args)))


(defn transform- [grammar rule options]
  (let [opts (apply assoc options)
        new-abbrev (assoc opts :from rule)
        old-abbrevs (:transforms @grammar)
        new-abbrevs (conj old-abbrevs new-abbrev)]
    (swap! grammar #(assoc % :transforms old-abbrevs))))

(defmacro transform [grammar rule & args]
  `(transform- ~grammar (quote ~rule) (quote ~args)))

(defgrammar lambda-calculus
  (defrule #"[a-z]\d*" :as variable)
  (defrule "(" A A ")" :as application)
  (defrule "(L" variable "." A ")" :as lambda)
  (defrule "(L" variable variable+ "." A ")" :as multilambda)
  
  (transform multilambda :to "(L" variable ".(L" variable+ "." A "))") :recursive true)

(defgrammar html
  (defrule #{"html" "head" "body" "div"} :as html-tag)
  (defrule "<" ))

(deflang c
  (defgrammar Term
    (defrule #"\d+" :as integer)
    (defrule #"[A-Za-z]\a+" :as varname)
    (defrule varname "(" term? ")" :as fun-appl))
  
  (defgrammar Misc
    (defrule #{"int" "float"} :as data-type))
  
  (defgrammar Stmt
    (defrule Misc/data-type #"\w+" Term/varname "\w+;")
    (defrule Term/varname #"\w+=
  
  (defrule #"\d+" :as integer)
  (defrule #"[A-Za-z]\a+" :as varname)
  (defrule c-type "\w+" varname ";" :as decl)
  (defrule varname "\w+=

(defn get-expr
  ([grammar string]
    (loop [rules (:rules grammar)]
      (if (empty? rules)
        (println "no match")
        (let [expr (get-expr grammar string (:rule (first rules)))]
          (if expr
            expr
            (recur (rest rules)))))))
  ([grammar string rule]
    (loop [expr-string ""
           remaining-rc rule
           bindings []]
      (if (empty? remaining-rc)
        {:expr expr-string, :bindings bindings}
        (let [rc (first remaining-rc)
              remaining-string (string-minus string expr-string)] ;rc = rule-component
          (cond
            (string? rc) (let [new-expr-string (str expr-string rc)]
                           (when (prefixes? new-expr-string string)
                             (recur new-expr-string
                                    (rest remaining-rc)
                                    bindings)))
            (regex? rc) (when-let [match (re-find rc remaining-string)]
                          (let [new-expr-string (str expr-string match)]
                            (when (prefixes? new-expr-string string)
                              (recur new-expr-string
                                     (rest remaining-rc)
                                     bindings))))
            (expr? rc) (when-let [next-expr (get-expr grammar remaining-string)]
                           (recur (str expr-string (:expr next-expr))
                                  (rest remaining-rc)
                                  (conj bindings next-expr)))
            (rule? rc) (do
                         (when-let [next-expr (get-expr grammar remaining-string (find-rule grammar rc))]
                           (recur (str expr-string (:expr next-expr))
                                  (rest remaining-rc)
                                  (conj bindings next-expr))))))))))
         

(defn -main [])

(declare get-expr)
(get-expr @lambda-calculus "(Lx.(Ly.y))")
