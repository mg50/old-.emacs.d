(ns tetris.core
  (:import (java.awt Color Dimension BorderLayout)
           (javax.swing JPanel JFrame JOptionPane JButton JLabel)
           (java.awt.event KeyListener))
  (:use clojure.contrib.import-static deflayout.core
        clojure.contrib-swing-utils)
  (:gen-class))

(import-static java.awt.event.KeyEvent VK_LEFT VK_RIGHT VK_DOWN VK_UP VK_SPACE)

(def empty-cell 0)
(def moving-cell 1)
(def filled-cell 2)
(def glass-width 10)
(def glass-height 20)
(def zero-coords [3 0])

(def stick [[0 0 0 0]
            [1 1 1 1]
            [0 0 0 0]
            [0 0 0 0]])

(def square [[1 1]
             [1 1]])

(def tblock [[0 0 0]
             [1 1 1]
             [0 1 0]])

(def sblock [[0 1 0]
             [0 1 1]
             [0 0 1]])

(def zblock [[0 0 1]
             [0 1 1]
             [0 1 0]])

(def lblock [[1 1 0]
             [0 1 0]
             [0 1 0]])

(def jblock [[0 1 1]
             [0 1 0]
             [0 1 0]])

(def figures [stick square tblock sblock zblock lblock jblock])

(defn create-vector (comp vec repeat))

(defn create-glass []
  (create-vector glass-height
                 (create-vector glass-width empty-cell)))

(defn pick-cell [figure x y]
  (get-in figure [y x]))

(defn mapmatrix [func matrix]
  (into [] (map-indexed (fn [y vect]
                          (into [] (map-indexed (fn [x el]
                                                  (func el x y))
                                                vect)))
                        matrix)))

(defn rotate-figure [fig]
  (let [fsize (count fig)]
    (mapmatrix #(pick-cell fig (- fsize %3 1) %2) fig)))

(defn apply-fig [glass fig [figx figy]]
  (let [fsize (count fig)]
    (mapmatrix (fn [el gx gy]
                 (if (and
                      (<= figx gx (+ figx fsize -1))
                      (<= figy gy (+ figy fsize -1)))
                   (+ el (pick-cell fig (- gx figx) (- gy figy)))
                   el)
                 glass))))


(defn destroy-filled [glass]
  (let [clear-glass (remove (fn [vect] (not-any? #(= % empty-cell) vect)) glass),
        destroyed (- glass-height (count clear-glas))]
    [(into (vect (repeat
                  destroyed
                  (create-vector glass-width empty-cell)))
           (vect clear-glass)),
     destroyed]))

(defn fix-figure [glass-with-fig]
  (mapmatrix (fn [el & _]
               (if (= el moving-cell)
                 filled-cell
                 el))
             glass-with-fig))

(defn count-cells [glass value]
  (reduce + (map (fn [vect]
                   (count (filter #(= % value) vect)))
                 glass)))

(defn legal? [glass]
  (= (count-cells glass moving-cell) 4))

(defn move
  ([glass fig [figx figy] shiftx shifty]
     (let [newx (+ figx shiftx),
           newy (+ figy shifty),
           newglass (apply-fig glass fig [newx newy])]
       (when (legal? newglass) [newx newy])))
  ([glass fig coords direction]
     (cond
       (= direction :down) (move glass fig coords 0 1)
       (= direction :left) (move glass fig coords -1 0)
       (= direction :right) (move glass fig coords 1 0))))

(def score-per-line 10)

(defmacro defatoms [& atoms]
  `(do
     ~@(map (fn [a#] `(def ~a# (atom nil))) atoms)))

(defatoms *glass* *fig-coords* *current-fig* *next-fig* *score*)

(defn complete-glass []
  (apply-fig @*glass* @*current-fig* @*fig-coords*))

(defn done-callback [n]
  (swap! *score* #(+ % (* n score-per-line))))

(defn move-to-side [dir]
  (let [newcoords (move @*glass* @*current-fig* @*fig-coords* dir)]
    (if newcoords
      (reset! *fig-coords* newcoords))))

(defn move-down []
  (let [newcoords (move @*glass* @*current-fig* @*fig-coords* :down)]
    (if newcoords
      (reset! *fig-coords* newcoords)
      (let [[newglass d-count] (-> (complete-glass)
                                   fix-figure
                                   destroy-filled)]
        (reset! *glass* newglass)
        (reset! *fig-coords* zero-coords)
        (reset! *current-fig* @*next-fig*)
        (reset! *next-fig* (rand-nth figures))
        (done-callback d-count)
        (when-not (legal? (complete-glass)) :lose)))))

(defn move-all-down []
  (move-down)
  (let [newcoords (move @*glass* @*current-fig* @*fig-coords* :down)]
    (when newcoords (recur))))

(defn rotate-current []
  (let [rotated (rotate-figure @*current-fig*)]
    (if (legal? (apply-fig @*glass* rotated @*fig-coords*))
      (swap! *current-fig* rotate-figure))))

(defn new-game []
  (reset! *glass* (create-glass))
  (reset! *fig-coords* zero-coords)
  (reset! *current-fig* (rand-nth figures))
  (reset! *next-fig* (rand-nth figures))
  (reset! *score* 0))
