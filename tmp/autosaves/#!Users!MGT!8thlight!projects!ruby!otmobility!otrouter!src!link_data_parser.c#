/* Parse the Postgres data into an in-memory representation. */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <stdint.h>
#include <stdbool.h>

#include "libpq-fe.h"

#include "astar.h"
#include "ht.h"
#include "spserver.h"
#include "link_data_parser.h"

extern ht_table *node_table;
extern struct arguments arguments;

static void exit_nicely(PGconn *conn) {
  PQfinish(conn);
  exit(1);
}


void  create_and_insert_node_descriptor(PGresult *res, int row) {
  NODE_T id;
  double x, y;

  id = atoll(PQgetvalue(res, row, 0));
  x = atoll(PQgetvalue(res, row, 1));
  y = atoll(PQgetvalue(res, row, 2));

  node_descriptor n = malloc(sizeof(node_descriptor));
  n.id = id;
  n.x = x;
  n.y = y;

  ht_insert(node_table, id, (ht_data_t)n);
}

void add_link_to_node(NODE_T node, link_descriptor *link) {
  node_descriptor 
}

void insert_link(PGresult *res, int row) {
  NODE_T link_id, feature_id, source, destination;
  COST_T length;
  double from_azimuth, to_azimuth;
  int speed_category, functional_class, access_pedestrian, count, alloced;
  link_descriptor link_descriptor;

  link_id = atoll(PQgetvalue(res, row, 0));
  source = atoll(PQgetvalue(res, row, 1));
  destination = atoll(PQgetvalue(res, row, 2));
  feature_id = atoll(PQgetvalue(res, row, 3));
  speed_category = atoi(PQgetvalue(res, row, 4));
  functional_class = atoi(PQgetvalue(res, row, 5));
  access_pedestrian = ('t' == *PQgetvalue(res, row, 6));
  length = atof(PQgetvalue(res, row, 7));
  from_azimuth = atof(PQgetvalue(res, row, 8));
  to_azimuth = atof(PQgetvalue(res, row, 9));

  link_descriptor = malloc(sizeof(link_descriptor));
  link_descriptor.link_id = link_id;
  link_descriptor.source = source;
  link_descriptor.destination = destination;
  link_descriptor.feature_id = feature_id;
  link_descriptor.speed_category = speed_category;
  link_descriptor.functional_class = functional_class;
  link_descriptor.length = length;
  link_descriptor.from_azimuth = from_azimuth;
  link_descriptor.to_azimuth = to_azimuth;
  link_descriptor.access_pe = access_pedestrian;
  link_descriptor.next = NULL;

  add_link_to_node(source, *link_descriptor);
  add_reverse_link_to_node(dest, *link_descriptor);
}

void insert_link(PGresult *res, int row) {
  NODE_T link_id, feature_id, source, destination;
  COST_T length;
  node_descriptor *node;
  double from_azimuth, to_azimuth;
  int speed_category, functional_class, access_pedestrian, count, alloced;

  link_id = atoll(PQgetvalue(res, row, 0));
  source = atoll(PQgetvalue(res, row, 1));
  destination = atoll(PQgetvalue(res, row, 2));
  feature_id = atoll(PQgetvalue(res, row, 3));
  speed_category = atoi(PQgetvalue(res, row, 4));
  functional_class = atoi(PQgetvalue(res, row, 5));
  access_pedestrian = ('t' == *PQgetvalue(res, row, 6));
  length = atof(PQgetvalue(res, row, 7));
  from_azimuth = atof(PQgetvalue(res, row, 8));
  to_azimuth = atof(PQgetvalue(res, row, 9));

  /* Sanity checks */
  assert(0 <= speed_category && speed_category <= 8);
  assert(0 <= functional_class && functional_class <= 5);

  /* NULL node is reserved for a N/A value when passed into the cost function.
   * Prohibit it from being used as an actual node or link ID. */
  assert(link_id != (NODE_T)NULL);
  assert(source != (NODE_T)NULL);
  assert(destination != (NODE_T)NULL);

  /* Self-loops could cause quite a few problems, so we'll prohibit them. */
  assert(source != destination);

  if(ht_lookup(node_table, source, (ht_data_t*)&node)) {

    /* Add on to the existing node record */
    count = node->link_count + 1;
    if(count > node->alloc_count) {
      node = realloc(node, sizeof(node_descriptor) +
                           (count * sizeof(link_descriptor)));
      node->alloc_count = count;
    }

    node->link_count = count;
    node->links[count-1].link_id = link_id;
    node->links[count-1].destination = destination;
    node->links[count-1].feature_id = feature_id;
    node->links[count-1].speed_category = speed_category;
    node->links[count-1].functional_class = functional_class;
    node->links[count-1].access_pedestrian = (bool)access_pedestrian;
    node->links[count-1].length = length;
    node->links[count-1].from_azimuth = from_azimuth;
    node->links[count-1].to_azimuth = to_azimuth;

    /* Re-insert the modified node into the hash table, since the realloc() may
     * have changed the pointer. We don't have to free the old node since
     * realloc() freed it if necessary. */
    ht_insert(node_table, source, (ht_data_t)node);
  } else {
    /* Create a new node record. We pre-allocate space for 3 links so as to
     * avoid realloc()s later. */
    alloced = 3;
    node = malloc(sizeof(node_descriptor) + alloced * sizeof(link_descriptor));
    node->id = source;
    node->x = 0.0; /* placeholders */
    node->y = 0.0;
    node->alloc_count = alloced;
    node->link_count = 1;
    node->links[0].link_id = link_id;
    node->links[0].destination = destination;
    node->links[0].feature_id = feature_id;
    node->links[0].speed_category = speed_category;
    node->links[0].functional_class = functional_class;
    node->links[0].access_pedestrian = (bool)access_pedestrian;
    node->links[0].length = length;
    node->links[0].from_azimuth = from_azimuth;
    node->links[0].to_azimuth = to_azimuth;
    ht_insert(node_table, source, (ht_data_t)node);
  }
}

void insert_node(PGresult *res, int row) {
  NODE_T id;
  double x, y;
  node_descriptor *node;

  id = atoll(PQgetvalue(res, row, 0));
  x = atoll(PQgetvalue(res, row, 1));
  y = atoll(PQgetvalue(res, row, 2));

  if(ht_lookup(node_table, id, (ht_data_t*)&node)) {
    node->x = x;
    node->y = y;
  } else {
    /* No need to pre-allocate space for links, as by this point we haven't
     * seen any links (since links are imported before nodes). */
    node = malloc(sizeof(node_descriptor));
    node->id = id;
    node->x = x;
    node->y = y;
    node->alloc_count = 0;
    node->link_count = 0;
    ht_insert(node_table, id, (ht_data_t)node);
  }
}

#define MAX_CONNECTION_STRING_SIZE 4096

void parse_link_data() {
  char *conninfo;
  PGconn *conn;
  PGresult *res;
  int i, numtuples;

  conninfo = malloc(MAX_CONNECTION_STRING_SIZE);
  /* XXX escape backslashes and single quotes in the input */
  snprintf(conninfo, MAX_CONNECTION_STRING_SIZE,
    "user = '%s' dbname = '%s' password = '%s' host = '%s' port = %d",
    arguments.postgresql_user, arguments.postgresql_database,
    arguments.postgresql_password, arguments.postgresql_host,
    arguments.postgresql_port);

  /* Set up node table */
  node_table = ht_init_numtable();

  conn = PQconnectdb(conninfo);
  if(PQstatus(conn) != CONNECTION_OK) {
    fprintf(stderr, "Connection to Postgres failed: %s",
      PQerrorMessage(conn));
    exit_nicely(conn);
  }

  /* TODO should this declare a portal? */
  res = PQexec(conn, "select link_id::int8, f_node_id::int8, t_node_id::int8, feature_id::int8, speed_category::int4, class::int4, access_pedestrian, length::float8, f_azimuth::float8, t_azimuth::float8 from public.link;");
  if(PQresultStatus(res) != PGRES_TUPLES_OK) {
    fprintf(stderr, "Fetching links failed: %s", PQerrorMessage(conn));
    PQclear(res);
    exit_nicely(conn);
  }

  numtuples = PQntuples(res);
  for(i=0; i<numtuples; ++i) {
    insert_link(res, i);
  }
  PQclear(res);

  /* Import nodes */
  res = PQexec(conn, "select node_id::int8, st_x(geog::geometry)::float8, st_y(geog::geometry)::float8 from public.node;");
  if(PQresultStatus(res) != PGRES_TUPLES_OK) {
    fprintf(stderr, "Fetching nodes failed: %s", PQerrorMessage(conn));
    PQclear(res);
    exit_nicely(conn);
  }

  numtuples = PQntuples(res);
  for(i=0; i<numtuples; ++i) {
    insert_node(res, i);
  }
  PQclear(res);

  PQfinish(conn);
  free(conninfo);
}
